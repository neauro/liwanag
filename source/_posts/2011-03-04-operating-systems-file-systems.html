---
layout: post
title: "Operating Systems: File Systems, Journaling File Systems"
date: 2011-03-04
comments: false
categories:
 - operating systems
 - notes
 - compsci
---

<div class='post'>
It's Thursday night/Friday morning, which means it's time to cram-study for the OS quiz tomorrow!  <span class="shh">This cram session brought to you by coke obtained at a Rails party at Joshu's place.</span><br /><br /><br /><span class="sig">File Systems</span><br />So we've most recently gone over file system stuff, <a href="http://nuubu.blogspot.com/2011/02/operating-system-notes-fat-file-system.html">a little bit</a> of which I've talked about (mostly FAT file systems.)<br /><br />File system in general have a couple simple roles:<ul><li>they implement an abstraction (files/directories) for storage of data</li><li>they logically organize files (i.e. into a hierarchy of directories)</li><li>they allow people to share data (in terms of access control, consistency)</li></ul><br />A <strong>file</strong> is basically just a collection of data which also has certain properties (i.e. size, owner, last modified date, etc.) Files also have "types" which allow them to be understood by the file system or by other programs -- i.e., a file can be a .txt, or an .exe, or a directory, which is actually just a generic "file" which contains a list of other files.  Types are encoded in a file's extension.<br /><br />Some file systems allow applications to access data in different ways -- i.e. sequentially (reading bytes one at a time), or by direct access (giving the application a block/byte number), or by indexed access (like a database), etc.<br /><br />Given some path name, like <code>C:\one\two\three</code>, the file system will access that folder first by opening <code>C:</code>, then searching for <code>one\</code>, then opening <code>one\</code>, then searching for <code>two\</code>, then opening <code>two\</code>...basically the file system spends a lot of time walking down directory paths, which is why "open" is usually a separate function from "read/write."  To make directory crawling go faster, the file system will cache some prefix lookups, like <code>C:\Windows</code>.<br /><br />File systems also have the happy job of implementing a protection system for its files, either by controlling who can access a file, or by controlling by whom a file is accessed.  Some models for representing protection are<ul><li><strong>access control lists (ACLs)</strong>, in which each object knows what user can do what with it, and</li><li><strong>capabilities</strong>, in which each user knows what they can do with each object.</li></ul><br />Capabilities can be handed off, which makes sharing easier; but ACLs are easier to manage, since you can just have a file and say, "This is system32, <em>no one write to this ever</em>."  ACLs can grow pretty large when an object is heavily shared between a lot of users, though they can be simplified by categorizing the users into "groups" (i.e. an object knows it can be altered by admins, but only read by normal users).<br /><br /><br /><span class="sig">Disks</span><br />So the file system goes on top of the disk, which has all dat memorys.  Disks are always divided into five parts:<ol><li>boot block, which contains information to boot the system</li><li>superblock, which specified boundaries of next areas and contains head of freelists of inodes and file blocks</li><li>i-node area, which contains descriptors for each file on disk</li><li>file contents area, the head of which is in the super-block, and the</li><li>swap area, which holds processes which have been swapped out of memory.</li></ol><br />An i-node is a data structure traditional to a Unix-style file system, and basically stores all the information about a regular file, directory, or file system object, other than its data and name.  Each file in a file system correspondes to one i-node.  I-nodes also contain a "block list," in the form of 13 block pointers, 10 of which are "direct pointers" to a block of data corresponding to a file.  The last 3 are pointers to pointers.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-_-IcQmBgdJQ/TXCzs3P_nAI/AAAAAAAAAJU/1kKKk4i5l4E/s1600/inodes.jpg" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="174" width="320" src="http://1.bp.blogspot.com/-_-IcQmBgdJQ/TXCzs3P_nAI/AAAAAAAAAJU/1kKKk4i5l4E/s320/inodes.jpg" /></a></div><br />I-nodes and file blocks are both cached in memory, only forced to be written to disk when the command "sync" is called by the operating system (every couple seconds).  If the computer crashes or has a power failure (i.e. you get frustrated with your computer and do a hard reset), you can have an inconsistent disk.  So, avoid hard resets!<br /><br />To make sure flat file systems are consistent, ask yourself: Does each block belong precisely to one file, or else is it free?  If you're looking at the consistency of a directory structure, do all the directories form a tree, and do the number of inodes equal the number of directories you'll find if you start crawling through all of them?<br /><br /><br /><br /><span class="sig">Journaling File Systems</span><br />So in light of the fact that crashes can and probably will happen when something is being written to disk, how do you make sure stuff stays consistent?  Here is where OS takes a lot of ideas from databases, specifically, atomicity and logs.  <strong>Atomicity</strong> is when you ensure that an action/set of actions are executed completely and perfectly, or else not at all.  <strong>Logs</strong> are a record of the actions that you've done to date.<br /><br /><strong>Journaling file systems</strong> are a special (yet dated to the 80s) type of file system which takes a advantage of redo logs.  The general idea is:<ul><li>always have a "home copy" of your data in a consistent/up-to-date state</li><li>make updates persistent by writing them in order to a "journal" partition or file on disk</li><li>at your leisure, push updates to the home copies to free up space in the journal</li><li>make sure that you've written a record of your action to your log before updating the disk</li></ul><br />Once an action/transaction has been "committed" to the log, you know for sure that you want it on disk.  So, if you crash, recover your log and redo all of the actions that you did there.  This fixes the problem that you might have committed something -- i.e. intended to write it to the disk -- but ran into a problem before you were actually able to write to disk.  Redo logs are the easiest type of log to implement.  <br /><br />Once you've got a log of your "committed" data, you can have another thread walk through it and flush items to disk.  Once an item has been flushed, it can be deleted from the log.<br /><br />The problem with the log is that it's one, big contiguous write -- so though it's efficient, it is another I/O, so it's really costly performance-wise.  Thus, journaling file systems can improve performance and make recovery really efficient, but isn't worth it in a really busy system.<br /><br /><br /><br />Sources:<br />lecture 14 notes<br />Wikipedia: <a href="http://en.wikipedia.org/wiki/I-node">inode</a></div>
