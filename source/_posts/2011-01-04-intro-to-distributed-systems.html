---
layout: post
title: "Intro to Distributed Systems"
date: 2011-01-04
comments: false
categories:
 - notes
 - distributed systems
 - compsci
---

<div class='post'>
So, for now at least, I'm taking a class on distributed systems.  <a href="http://code.google.com/edu/parallel/dsd-tutorial.html">Google</a> has a good tutorial on what a distributed system is, which I will take notes from/copy shamelessly.<br /><br />Firstly, definitions --<br /><strong>A protocol</strong> is "a formal description of message formats and the rules that two processes must follow in order to exchange those messages."<br /><br /><strong>A network</strong> is "the infrastructure that links computers, workstations, terminals, servers, etc.  It consists of routers which are connected by communiation links."<br /><br /><strong>A distributed system</strong> is "an application that executes a collection of protocols to coordinate the actions of multiple processes on a network, such that all components cooperate together to form a single or small set of related tasks."<br /><br />My impression of it currently is also like this: a distributed system is a program that controls a ton of computers and with their powers combined accomplishes great things, like searching the internets for that picture of Maru wearing a crab hat.<br /><br /><br /><span class="sig">Advantages of a distributed system:</span> <br />Distributed systems can connect remote users with remote resources in an open and scalable way.  <em>Open</em> meaning that each component of the system can interact with other components at any time, <em>scalable</em> meaning that the system can be easily altered to accomodate changes in the amount of users or resources.<br /><br /><br /><span class="sig">Disadvantages of a distributed system:</span><br />A system of things working together is more complicated than a system of something working by itself.  An example of this is an airplane with two engines, which spend much more time on the ground than airplanes with a single engine, simply because planes cannot take off if anything is wrong with them, and there's more to go wrong with an airplane that has more engines.<br /><br />Distributed systems have a lot of complexity because its components, the computers or servers or etc., have to interact properly.  An example of how difficuult the interaction can be can be found with the <strong>two generals problem</strong>, which goes like this:<br /><br /><blockquote>Two generals on opposite hillsides want to coordinate an attack.  General A sends a message -- "Let's attack at dawn!" -- to General B.  How will General A know if General B agrees?  B will send a message in response -- "Alright, let's attack at dawn!" But then how will B know that A received his confirmation?  A will have to send a message back.  And then how will A know that B got the confirmation message?  B will have to send a message back...</blockquote><br />And so on and so forth.<br /><br /><br /><span class="sig">So, a well-designed distributed system will have these characteristics:</span><br /><ol><li>Fault-tolerant: if a components fails, it can recover without performing incorrect actions</li><li>Highly available: if a component fails, it can restore operations and continue to provide services</li><li>Recoverable: if a component fails, it can restart itself and rejoin the system after failure has been fixed</li><li>Consistent: in the event of failure, a system can still coordinate components</li><li>Scalable: if some aspect of the system is scaled to a larger size (i.e. if there are more users, or size of network increases), then the system can still work correctly</li><li>Predictable performance: the system can provide responsiveness in a timely fashion</li><li>Secure: the system can authenticate access to data and services</li></ol><br />With distributed systems, you have to <em>design for failure</em>.  If I told you to do something and you didn't do it, is it because I didn't tell you clearly what to do?  Or is it because you didn't see me tell you?  Or is it because I didn't get confirmation that you had done it?  This problem is the reason why distributed systems are so hard to debug -- it's hard to see where exactly the problem originated, or why it happened.<br /><br /><br /><span class="sig">Distributed systems design</span><br />Firstly, about client-server applications.  They work by having a <em>server</em> which provides some service, like processing database queries, and a <em>client</em> which uses the service, i.e. to show the database query results.  Different types of servers do different things: for instance, a database server houses databases and allows clients to access them, file servers manage disk storage, etc.  The communication between client and server needs to be reliable.<br /><br />Reliability is governed by protocols, like TCP/IP.  The Internet Protocol (IP) is a set of communication protocols that allow for communication on the internet and most commercial networks.  The Transmission Control Protocol (TCP) is a core part of IP, and allows clients and servers to create connections to one another and exchange data in "packets." Protocol guarantees reliable and in-order delivery of data from sender to receiver.<br /><br />With a distributed system, there can be many types of servers, and <em>service</em> is a term that refers to a set of servers of a particular type.  "Binding" is when a process that needs to access a service becomes associated with a particular server which provides the service.  Programs which which server to associate with through binding policies.  For example, someone looking for certain information on a database may be connected to a server which is closest to them geographically, so that access is faster, or he or she may be connected to a database which has the least number of people presently accessing it.<br /><br />To keep things reliable, a distributed service may keep multiple copies of data so you can still access it if something goes wrong.  To keep things going fast, a distributed service may <em>cache</em> data, which is when it makes copies of the data and keeps a copy of it locally, so the data can be accessed quickly the next time it's wanted.  <br /><br /><br /><span class="sig">More about TCP/IP</span><br />The IP "suite" can be viewed as a set of layers, in which each layer uses the functions of the layers below it and gives functionality to the layer above it.  The lower layers are typically implemented in hardware, whereas the higher layers are implemented in software.<br /><br />The layers:<br /><ol><li>Application layer: is used by most programs that require netwrok communication.  The program gives data to this layer of protocol, and then encapsulated in a transport layer protocol.  Examples of applications that use this layer: HTTP, FTP. </li><li>Transport layer: is responsible for end-to-end message transfer, along with error control, fragmentation, and flow control.  End-to-end message transmission can be categorized as <em>connection-oriented</em> (TCP) or <em>connectionless</em> (UDP), with TCP being the more sophisticated and reliable.<br /></li><ul><li>TCP works by: first, ensuring the receiving computer is ready to accept data by using a "three-packet handshake" in which the sender and receiver agree they're ready to communicate.  Then, TCP makes sure data gets to its destination.  If the receiver doesn't acknowledge a packet of the data, TCP will automatically transmit the packet three times, and also split the large packet into smaller ones if needed so that the data can travel more reliably.  TCP will also drop duplicate packets and rearrange the ones that arrive out of sequence.</li><li>Note for self: What's the relationship between this and torrenting something?  Also, I understand that TCP is a protocol, which means that it's a "formal description," so what's with this "TCP making sure data reaches" and "TCP automatically transmitting" stuff as if it's a program which does something?</li></ul><li>Network layer: solves the problem of getting packets across a single network, or, getting packets from one network to another network by moving the packet across a network of networks, i.e. the Internets.  IP performs the basic task of getting packets of data from source to destination.</li><li>Link layer: deals with the physical transmission of data, i.e. placing frame headers and trailers on packets for travelling over the physical network, and dealing with physical components.</li></ol><br /><br /><span class="sig">Remote Procedure Calls (RPCs)</span><br />A remote procedure call (RPC) is another method besides TCP/IP that clients can use to interact with servers.  It's based off the idea that the procedure that a client wants to use may not be in the same "address space," i.e. the procedure is off on a different system with a network connecting them.<br /><br />So, when an RCP is made, the arguments are passed to a remote procedure and the caller waits for a response or a timeout.  Each incoming request to a server usually spawns a new thread, and a thread in the client issues an RPC and then waits, and resumes execution when it receives a reply.<br /><br />RPC-based code needs to do three things:<br /><ol><li>Specify the protocol for client-server communication</li><ul><li>The protocol is created by <em>stubs</em>, which are generated by a protocol compiler.  A stub is a routine that doesn't do much other than to declare itself and the parameters it accepts -- just enough to allow it to be compiled and linked.</li></ul><li>Develop the client program, which will call the remote procedure, pass it the required data, and receive returned data</li><li>Develop the server program, which will register the procedures that may be called by a client, and receive/return data required for processing.</li></ol><br />So, an RPC application uses classes made by the stub generator to execute an RPC, and then wait for it to finish.<br /><br />Some errors that may happen in RPC programming are binding errors, which will happen when a server isn't running when a client is started); or version mismatches, if a client compiled against an outdated version of the server.  Timeouts will occur in the case of a server crash, network problem, or client computer problem.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/_SdPKamJbrgg/TSN28QczM5I/AAAAAAAAADc/gDZxppbry4c/s1600/DSC_1015.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://2.bp.blogspot.com/_SdPKamJbrgg/TSN28QczM5I/AAAAAAAAADc/gDZxppbry4c/s320/DSC_1015.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">(<a href="http://sisinmaru.blog17.fc2.com/blog-entry-47.html">source</a>)</td></tr></tbody></table><br />Sources:<br /><a href="http://code.google.com/edu/parallel/dsd-tutorial.html">Google: Introduction to Distributed System Design</a><br />Lecture notes</div>
