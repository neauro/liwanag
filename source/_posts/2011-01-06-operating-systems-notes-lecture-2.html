---
layout: post
title: "Operating Systems Notes [Lecture 2]"
date: 2011-01-06
comments: false
categories:
 - operating systems
 - notes
 - compsci
---

<div class='post'>
An operating system provides <a href="http://nuubu.blogspot.com/2011/01/operating-system-notes-chapter-1.html">a middle ground</a> between hardware and software, so making an operating system depends a lot on what hardware you have underlying it.  Computer hardware, however, has the amazing capacity to (at least until fairly recently) follow <strong>Moore's Law</strong>, which states that <em>the number of transistors that can be placed inexpensively on an integrated circuit has doubled approximately every two years.</em>  I guess this trend has persisted for half a century, making it so that processors and memory have become ridiculously cheap, ridiculously fast.<br /><br />What this means is, the hardware conditions that you assume and initially create your operating system for may not hold true, and then you'll be screwed.<br /><br />One interesting thing is that, though processor performance has increased throughout the years, disk capacity has become 10x as fast as processor performance.  Disk performance has <em>not</em> kept up, having only increased by a factor of 200 since 1983 (from 500 kb/s to ~100 mb/s).  Bandwidth presently is 100x as fast as processor performance, and 10x as fast as disk performance.<br /><br />An obvious implication of these unexpected growths is this: What happens if you have always designed systems so that they spend processing power so as to save "scarce" storage and bandwidth?<br /><br />Another thing: operating systems must load programs into main memory in order to execute them, but main memory is not large enough to hold everything all at once, and occasionally you'll have to fetch data from the disc.  A computer going out of its way to fetch data from the disc is like a human going out of its way to fetch something from Pluto.  <em>Uphill.  Both ways.  In space.</em><br /><br />In general, hardware can dictate a lot about how simple or complex it will be to implement an OS.  Early OS (like DOS) didn't have virtual memory, because the hardware didn't allow it; and until recently, Intel-based PCs still didn't support 64-bit addressing, though other platforms have had it since forever, like IBM, MIPS, etc.<br /><br />Features were also sometimes built into hardware to support OS building, like timer operation, memory protection, interrupts and exceptions, system calls.<br /><br /><strong>System calls</strong> are there so that the user can call an OS procedure, which is otherwise protected and kept out of hand's reach on top of the refridgerator in kernel mode, so that the user doesn't eat it all and spill it all over everything.  Once the user is done having a dessert cookie, the OS moves back into user mode, and relinquishes control back to the user.<br /><br />The kernel must save the state that the user was in before the user wanted to eat a cookie, so that it can remember what it was doing before it was interrupted, and resume.<br /><br />So in general the OS sits around waiting for events to happen that it can deal with.  Events can be interrupts, which are sent by programs, or they can be exceptions.  <strong>Exceptions</strong> are thrown by hardware once it detects certain rules being violated (like if someone tries to write to a read-only file), and when they happen control must be passed to the OS's handler, with the saved state at the time of the fault.  Exceptions are a performance optimization in that the OS doesn't have to deal with figuring out when things are going wrong -- the hardware detects the violation -- and detecting exceptions would be a big hassle for the OS because those extra checks would have to be written into the kernel, taking valuable space.<br /><br />In the meantime, interrupts allow for <strong>asynchronous I/O</strong>.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/_SdPKamJbrgg/TSasz1jh5fI/AAAAAAAAAD8/9lBMBA1S9E0/s1600/os%2Bio%2Bcontrol.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://1.bp.blogspot.com/_SdPKamJbrgg/TSasz1jh5fI/AAAAAAAAAD8/9lBMBA1S9E0/s320/os%2Bio%2Bcontrol.jpg" width="246" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">this is how we deal with I/O interrupts around here</td></tr></tbody></table><br />So, I/O interrupts can happen at any time, any place.  How do you protect yourself from getting interrupted so much that you end up never getting anything done?  Your OS will have to be able to <strong>synchronize concurrent processes</strong> by guaranteeing that short instructions (read-modify-write) will happen automatically; or maybe, by not letting certain processes get interrupted until their finished; or maybe, by having special atomic instructions, such as the read-modify-write, which you execute immediately.<br /><br /><strong>Concurrent programming</strong> is a huge deal and is a huge difference between systems programming and "traditional application programming," which I'm starting to feel is like, the lame computer programming.<br /><br /><br /><br />Sources:<br />Lecture 2 notes<br /><a href="http://en.wikipedia.org/wiki/Moore's_law">Wikipedia: Moore's Law</a></div>
